
----------------------------------------
declare void @main.omp_outlined(noundef ptr, noundef ptr)
declare void @__kmpc_fork_call(ptr, i32, ptr, ...)

@2 = constant 24 bytes, align 8
@main.omp_outlined = constant ? bytes, align 8
@0 = constant 23 bytes, align 1

define i32 @main() noundef {
init:
  %__copy_0 = {i32, i32, i32, i32, ptr} { 0, 2, 0, 22, @0 }
  store [23 x i8] { 59, 117, 110, 107, 110, 111, 119, 110, 59, 117, 110, 107, 110, 111, 119, 110, 59, 48, 59, 48, 59, 59, 0 }, ptr @0, align 1
  store {i32, i32, i32, i32, ptr} %__copy_0, ptr @2, align 8
  br label %#0

#0:
  %#1 = alloca i64 4, align 4
  store i32 0, ptr %#1, align 4
  call void @__kmpc_fork_call(ptr @2, i32 0, ptr @main.omp_outlined)
  ret i32 0
}
=>
@2 = constant 24 bytes, align 8
@main.omp_outlined = constant ? bytes, align 8
@0 = constant 23 bytes, align 1

define i32 @main() noundef {
#0:
  %#5 = alloca i64 4, align 4
  %#6 = alloca i64 4, align 4
  store i32 0, ptr %#5, align 4
  store i32 0, ptr %#6, align 4
  br label %#1

#1:
  %#7 = load i32, ptr %#6, align 4
  %#8 = icmp slt i32 %#7, 5
  br i1 %#8, label %#2, label %#4

#2:
  br label %#3

#3:
  %#9 = load i32, ptr %#6, align 4
  %#10 = add nsw i32 %#9, 1
  store i32 %#10, ptr %#6, align 4
  br label %#1#2

#1#2:
  %#7#2 = load i32, ptr %#6, align 4
  %#8#2 = icmp slt i32 %#7#2, 5
  br i1 %#8#2, label %#2#2, label %#4

#2#2:
  br label %#3#2

#3#2:
  %#9#2 = load i32, ptr %#6, align 4
  %#10#2 = add nsw i32 %#9#2, 1
  store i32 %#10#2, ptr %#6, align 4
  br label %#1#3

#1#3:
  %#7#3 = load i32, ptr %#6, align 4
  %#8#3 = icmp slt i32 %#7#3, 5
  br i1 %#8#3, label %#2#3, label %#4

#2#3:
  br label %#3#3

#3#3:
  %#9#3 = load i32, ptr %#6, align 4
  %#10#3 = add nsw i32 %#9#3, 1
  store i32 %#10#3, ptr %#6, align 4
  br label %#1#4

#1#4:
  %#7#4 = load i32, ptr %#6, align 4
  %#8#4 = icmp slt i32 %#7#4, 5
  br i1 %#8#4, label %#2#4, label %#4

#2#4:
  br label %#3#4

#3#4:
  %#9#4 = load i32, ptr %#6, align 4
  %#10#4 = add nsw i32 %#9#4, 1
  store i32 %#10#4, ptr %#6, align 4
  br label %#1#5

#1#5:
  %#7#5 = load i32, ptr %#6, align 4
  %#8#5 = icmp slt i32 %#7#5, 5
  br i1 %#8#5, label %#2#5, label %#4

#2#5:
  br label %#3#5

#3#5:
  %#9#5 = load i32, ptr %#6, align 4
  %#10#5 = add nsw i32 %#9#5, 1
  store i32 %#10#5, ptr %#6, align 4
  br label %#1#exit

#1#exit:
  %#7#exit = load i32, ptr %#6, align 4
  %#8#exit = icmp slt i32 %#7#exit, 5
  br i1 %#8#exit, label #sink, label %#4

#4:
  ret i32 0
}
Transformation doesn't verify!

ERROR: Source and target don't have the same return domain

Example:

Source:
{i32, i32, i32, i32, ptr} %__copy_0 = { #x00000000 (0), #x00000002 (2), #x00000000 (0), #x00000016 (22), pointer(non-local, block_id=3, offset=0) / Address=#x084 }
  >> Jump to %#0
ptr %#1 = pointer(local, block_id=0, offset=0) / Address=#x100
void = function did not return!

SOURCE MEMORY STATE
===================
NON-LOCAL BLOCKS:
Block 0 >	size: 0	align: 1	alloc type: 0	alive: false	address: 0
Block 1 >	size: 24	align: 8	alloc type: 0	alive: true	address: 8	const
Block 2 >	size: 15	align: 8	alloc type: 0	alive: true	address: 64	const
Block 3 >	size: 23	align: 1	alloc type: 0	alive: true	address: 132	const
Block 4 >	size: 5	align: 1	alloc type: 0	alive: true	address: 2

LOCAL BLOCKS:
Block 8 >	size: 4	align: 4	alloc type: 1	alive: true	address: 256

Target:
ptr %#5 = pointer(local, block_id=0, offset=0) / Address=#x100
ptr %#6 = pointer(local, block_id=1, offset=0) / Address=#x120
  >> Jump to %#1
i32 %#7 = #x00000000 (0)
i1 %#8 = #x1 (1)
  >> Jump to %#2
  >> Jump to %#3
i32 %#9 = #x00000000 (0)
i32 %#10 = #x00000001 (1)
  >> Jump to %#1#2
i32 %#7#2 = #x00000001 (1)
i1 %#8#2 = #x1 (1)
  >> Jump to %#2#2
  >> Jump to %#3#2
i32 %#9#2 = #x00000001 (1)
i32 %#10#2 = #x00000002 (2)
  >> Jump to %#1#3
i32 %#7#3 = #x00000002 (2)
i1 %#8#3 = #x1 (1)
  >> Jump to %#2#3
  >> Jump to %#3#3
i32 %#9#3 = #x00000002 (2)
i32 %#10#3 = #x00000003 (3)
  >> Jump to %#1#4
i32 %#7#4 = #x00000003 (3)
i1 %#8#4 = #x1 (1)
  >> Jump to %#2#4
  >> Jump to %#3#4
i32 %#9#4 = #x00000003 (3)
i32 %#10#4 = #x00000004 (4)
  >> Jump to %#1#5
i32 %#7#5 = #x00000004 (4)
i1 %#8#5 = #x1 (1)
  >> Jump to %#2#5
  >> Jump to %#3#5
i32 %#9#5 = #x00000004 (4)
i32 %#10#5 = #x00000005 (5)
  >> Jump to %#1#exit
i32 %#7#exit = #x00000005 (5)
i1 %#8#exit = #x0 (0)
  >> Jump to %#4

TARGET MEMORY STATE
===================
LOCAL BLOCKS:
Block 8 >	size: 4	align: 4	alloc type: 1	alive: true	address: 256
Block 9 >	size: 4	align: 4	alloc type: 1	alive: true	address: 288


Summary:
  0 correct transformations
  1 incorrect transformations
  0 failed-to-prove transformations
  0 Alive2 errors
